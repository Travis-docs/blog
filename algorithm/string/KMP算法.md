## 基本介绍

KMP算法针对的场景可以简单概括为：确定模式串pattern是否是文本串text的子串，换句话讲，text是否包含pattern字符串。

KMP算法是先遍历pattern串获取一些有用信息，根据这些信息构造一个数组next，用来标记每次比较失败后下次需要比较的位置。

在KMP算法以前，假设我们想要判断模式串pattern是否是文本串text的子串，一般步骤如下：

1. 使用两个指针i、j分别标记"aaacaaaaaaab"和“aaab”现在遍历到的位置；
2. i、j从0开始，比较text[i]和pattern[j]是否相等，如果相等，i和j自增，如果不相等，则i置为1，j置为0又重新进行比较，一直重复，直到下标i走到位置`text.length()-pattern.length()+1`（匹配失败）或j走到位置`pattern.length()`（匹配成功）；

而使用KMP算法，我们则可以先对pattern串构造有效信息，每次发现不匹配的位置时不用把i倒退，也不用直接把j置为0，这大大减少了字符比对的次数，暴力破解的时间复杂度是O(m*n)（m和n分别是模式串和文本串的长度），KMP算法的时间复杂度为O(m+n)。

## 算法流程

下面先讲述一下KMP算法的流程，如果不想清楚原理的也只需要记住这一步骤即可解决字符串匹配的一系列问题。

举个例子：

我们想要判断`String pattern = "aaab"`是否是`String text = "aaacaaaaaaab"`的子串，如果使用KMP算法，我们的步骤如下：

1. 我们需要创建一个数组：`int[] next = new int[pattern.length()]`，这个next数组记录的信息如下：next[i]表示模式串在下标i之前的子串最长相等的前后缀长度；

2. 根据模式串填充next数组，如“aaab”我们填充如下：

   1. 对于下标0，我们填-1；
   2. 对于下标1，由于前面的子串长度只有1，所以不存在前缀后缀，填0；
   3. 对于下标2，前面的子串为“aa”，最长相等的前后缀为”a“，填1；
   4. 对于下标3，前面的子串为“aaa”，最长相等的前后缀为“aa”，填2；

   因此，得到的next数组如下：

   | 0    | 1    | 2    | 3    |
   | ---- | ---- | ---- | ---- |
   | -1   | 0    | 1    | 2    |

3. 使用两个指针i、j分别标记text串和pattern串遍历到的位置，并分如下情况讨论：

   1. 如果`j==pattern.length()`，则匹配成功；
   2. 如果`i==text.length()&&j!=pattern.length()`，则匹配失败，退出算法；
   3. 如果`text[i]==pattern[j]`，则i、j都自增；
   4. 如果`text[i]!=pattern[j]`，则查看j的值：
      1. `j==0`：i++；
      2. `j>0`：`j=next[j]`；

针对上述的例子，"aaacaaaab"`和"aaab"，按KMP算法的比较过程如下：

1. i和j都增加到3，此时text[3]='c'，pattern[3]='b'，两者不等；
2. j=next[j]得到j=2，此时i仍为3，text[3]='c'，pattern[2]=‘a'，不相等，一直重复直到j=0；
3. j=0，此时i仍为3，text[3]='c'，pattern[0]=‘a'，不相等，因此i自增为4；
4. 此时i=4，j=0，两者进行比对，由于字符相等，i、j一直增加到i=7，j=3，此时text[7]=’a'，pattern[3]='b'，两者不等；
5. j=next[j]得到j=2，此时i仍为7，text[7]='a'，pattern[2]=‘a'，两者相等，i、j增加；
6. 此时i=8，j=3，两者相等，j增加达到4，等于pattern.length()，比对成功；

在这个过程中，由于i是没有回退的，j虽然有，但是根据next数组也不会每次直接回退到位置0，所以减少了很多无用的对比，相比暴力破解优化了许多。

## 算法原理

在这一节，笔者主要带大家探讨为什么next数组能够保证跳转后不会错过正确的比对情况，即KMP的正确性如何证明？

例如对于文本串"abadabab"和模式串"abab"，在i、j都为3，即文本串遍历到'd'、模式串遍历到'b'的时候会发现不相等的情况，按照KMP算法的处理，j会回退到1，也就是此时比对的情况如下，简称表1：

| a    | b    | a    | d               | a    | b    | a    | b    |
| ---- | ---- | ---- | --------------- | ---- | ---- | ---- | ---- |
|      |      | a    | **b**(将要比对) | a    | b    |      |      |

可以看到模式串跳过了下面这种比对情况，简称表2：

| a    | b    | a    | d    | a    | b    | a    | b    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | a    | b    | a    | b    |      |      |      |

对于该例子我们当然可以确定表2的情况不可能对比成功，但KMP算法如何泛化证明跳过的比对情况都是不正确的呢？

我们可以利用反证法：

对于文本串`p0 p1 p2...pk s1 ...`

和模式串`p0 p1 ... pk s2 ...`注意，**p开头的字符只是象征性符号，代表某个未知的确定字符，且s2!=s2**。

假设next[idx(s2)]=m<k`，根据KMP下一步比对情况如下：

| p0   | p1   | ...  | p(k-m+1) | p(k-m+2) | ...  | pk     | s1   |
| ---- | ---- | ---- | -------- | -------- | ---- | ------ | ---- |
|      |      |      | p0       | p1       | ...  | p(m-1) | pm   |

假设KMP算法是错误的，即我们跳过了某个匹配成功的情况如下，取n>0：

| p0   | p1   | ...  | p(k-m-n+1) | p(k-m-n+2) | ...  | pk       | s1     |
| ---- | ---- | ---- | ---------- | ---------- | ---- | -------- | ------ |
|      |      |      | p0         | p1         | ...  | p(m+n-1) | p(m+n) |

在该情况下，我们可以得到

- p(k-m-n+1)=p1
- p(k-m-n+2)=p2
- ...
- pk=p(m+n)

恰巧p1-p(m+n)是p1-pk的前缀，p(k-m-n+1)-pk是p1-pk的后缀，且相等的长度为`m+n>m`，因此`next[idx(s2)]`的值此时不可能为m，产生矛盾。

## 后记

KMP算法最早接触是在准备考研的时候，由于没有打过ACM算法基础不扎实，当时被KMP困扰了许久，最近想起觉得这是个很有趣的算法，而且网上很多资料只是介绍了KMP算法的流程却没有对其正确性的说明，且流程说明有时也过度繁琐复杂，因此笔者写下了这篇博客，在简单的流程说明后面又添加了对KMP算法正确性的证明。

关于KMP算法其实有挺多有趣的值得探讨的地方，next数组的计算可以用dp的思想去做，这样只遍历模式串一次就可以得到，而根据next数组跳转又有一点贪心算法的思想在里面，且KMP算法的正确性证明如何得到，这都是值得思考的问题。这里提出另外一个小问题，由于笔者时间有限就没有去研究，希望读者看到后能去再进一步思考一下，为什么KMP的时间复杂度是O(m+n)，在上述文章中我们可以看出，模式串的下标是有回退的，在这个前提下如何证明KMP的时间复杂度我认为是个有趣的问题。